# name: CD-Deploy-EKS

# on:
#   push:
#     branches: [ main ]
#     paths:
#       - 'k8s/**'
#       - '.github/workflows/cd.yml'
#       - 'Dockerfile'
#       - 'pom.xml'
#       - 'src/**'
#   workflow_dispatch:

# permissions:
#   id-token: write
#   contents: read

# env:
#   AWS_REGION: ${{ secrets.AWS_REGION }}
#   AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
#   ECR_REPO: ${{ secrets.ECR_REPO }}
#   EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
#   K8S_NAMESPACE: ecom
#   DOCKER_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_REPO }}
#   IMAGE_TAG: ${{ github.sha }}

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     environment: dev
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Configure AWS credentials (OIDC)
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Update kubeconfig
#         run: |
#           aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION
#           kubectl version --client=true

#       - name: Create namespace if not exists
#         run: |
#           kubectl get ns $K8S_NAMESPACE || kubectl create ns $K8S_NAMESPACE

#       - name: Create/Update DB secret from GitHub Secrets
#         run: |
#           cat <<EOF | kubectl apply -f -
#           apiVersion: v1
#           kind: Secret
#           metadata:
#             name: ecom-db
#             namespace: $K8S_NAMESPACE
#           type: Opaque
#           stringData:
#             DB_HOST: "${{ secrets.DB_HOST }}"
#             DB_NAME: "${{ secrets.DB_NAME }}"
#             DB_USER: "${{ secrets.DB_USER }}"
#             DB_PASSWORD: "${{ secrets.DB_PASSWORD }}"
#           EOF

#       - name: Prepare manifests (inject image URI & tag)
#         run: |
#           mkdir -p /tmp/k8s
#           rsync -a k8s/ /tmp/k8s/
#           find /tmp/k8s -type f -name '*.yaml' -print -exec sed -i "s|<ECR_URI>|$DOCKER_IMAGE|g" {} +
#           find /tmp/k8s -type f -name '*.yaml' -print -exec sed -i "s|\${IMAGE_TAG}|$IMAGE_TAG|g" {} +
#           echo '---'; cat /tmp/k8s/deployment.yaml || true

#       - name: Apply manifests
#         run: |
#           kubectl apply -k /tmp/k8s

#       - name: Wait for rollout
#         run: |
#           kubectl -n $K8S_NAMESPACE rollout status deployment/ecom-web --timeout=180s

#       - name: Show Service & Ingress
#         run: |
#           kubectl -n $K8S_NAMESPACE get svc ecom-web-svc -o wide || true
#           kubectl -n $K8S_NAMESPACE get ing ecom-web-ing -o wide || true
#           echo -n "ALB Hostname: "
#           kubectl -n $K8S_NAMESPACE get ing ecom-web-ing -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true
#           echo

#       - name: Slack notify (success)
#         if: success() && env.SLACK_WEBHOOK_URL != null
#         uses: rtCamp/action-slack-notify@v2
#         env:
#           SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
#           SLACK_COLOR: good
#           SLACK_MESSAGE: |
#             üöÄ Deployed to EKS cluster: ${{ env.EKS_CLUSTER_NAME }}
#             Namespace: ${{ env.K8S_NAMESPACE }}
#             Image: ${{ env.DOCKER_IMAGE }}:${{ env.IMAGE_TAG }}
#             Ingress: $(kubectl -n ${{ env.K8S_NAMESPACE }} get ing ecom-web-ing -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

#   notify-on-failure:
#     needs: [deploy]
#     runs-on: ubuntu-latest
#     if: failure()
#     steps:
#       - name: Slack notify (failure)
#         if: env.SLACK_WEBHOOK_URL != null
#         uses: rtCamp/action-slack-notify@v2
#         env:
#           SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
#           SLACK_COLOR: danger
#           SLACK_MESSAGE: |
#             ‚ùå Deployment failed for ${{ github.repository }}@${{ github.sha }}
